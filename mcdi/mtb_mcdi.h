/***************************************************************************//**
* \file mtb_mcdi.h
* \version 1.0
*
* \brief
* Provides private declarations for the MCDI library.
*
********************************************************************************
* \copyright
* (c) (2024), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation. All rights reserved.
********************************************************************************
* This software, including source code, documentation and related materials
* ("Software") is owned by Cypress Semiconductor Corporation or one of its
* affiliates ("Cypress") and is protected by and subject to worldwide patent
* protection (United States and foreign), United States copyright laws and
* international treaty provisions. Therefore, you may use this Software only
* as provided in the license agreement accompanying the software package from
* which you obtained this Software ("EULA").
*
* If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
* non-transferable license to copy, modify, and compile the Software source
* code solely for use in connection with Cypress's integrated circuit products.
* Any reproduction, modification, translation, compilation, or representation
* of this Software except as specified above is prohibited without the express
* written permission of Cypress.
*
* Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. Cypress
* reserves the right to make changes to the Software without notice. Cypress
* does not assume any liability arising out of the application or use of the
* Software or any product or circuit described in the Software. Cypress does
* not authorize its products for use in any products where a malfunction or
* failure of the Cypress product may reasonably be expected to result in
* significant property damage, injury or death ("High Risk Product"). By
* including Cypress's product in a High Risk Product, the manufacturer of such
* system or application assumes all risk of such use and in doing so agrees to
* indemnify Cypress against all liability.
*******************************************************************************/

/**
 *<!-- The MCDI documentation structure -->
 * \defgroup group_mcdi_general Motor Control Driver Interface (MCDI)
 * \{
 *  \defgroup group_mcdi_macros Macros
 *  \defgroup group_mcdi_enums Enumerated Types
 *  \{
 *    \defgroup group_mcdi_status Status
 *    \defgroup group_mcdi_topologies Topologies
 *  \}
 *  \defgroup group_mcdi_data_structures Data Structures
 *  \defgroup group_mcdi_functions Functions
 *  \defgroup group_mcdi_gen_func Generated Functions
 *  \cond SECTION_MDI_INTERNAL
 *  \defgroup group_mtb_mcdi_internal Internal Functions
 *  \endcond
 * \}
 *<!-- End of the MCDI documentation structure -->
 *
 * \addtogroup group_mcdi_general
 * \{
 * The MCDI represents the device-agnostic top-level API source code, the control
 * service code, and the Solution Personality.
 * The Solution Personality:
 * - provides the integration with the Device Configurator
 * - provides a graphical configuration interface
 * - generates device-specific HW configuration code and the control code for the motor
 *   control applications
 * - generates templates for the fast and slow control loop ISRs
 * - supports single-shunt and three-shunt load current measurement schemes
 * - supports up-to-two motor instances
 *
 * \image html MCDI_structure.png width=50%
 *
 * \section section_mcdi_quick_start Quick Start
 * \{
 * In order to use the MCDI as a standalone interface for alternative motor control libraries:
 *
 * - Create a New Application in ModusToolbox&trade; IDE
 * \par
 * \image html MakeNewApp.png width=9%
 *
 * - Use the 'Empty App' template.
 * \par
 * \image html UseTemplate.png
 *
 * - Add the 'motor-ctrl-lib' to the created application using the Library Manager
 * \par
 * \image html UseLibraryManager.png width=10%
 *
 * - Add this code into the project 'Makefile'
 * \par
 * \image html MakefileContent.png
 *
 * - Launch the Device Configurator
 * \par
 * \image html LaunchDeviceConfigurator.png width=12%
 *
 * - Add the Motor Control instance
 * \par
 * \image html myMotor.png
 *
 * - Configure all hardware-specific Motor Control solution parameters and save them (or press Ctrl+S to save).
 * After that, the appropriate code for the application will be generated by the Solution Personality.
 *
 * - Add both the \ref myMotor_slow_callback function definition and the \ref myMotor_fast_callback function
 * definition into the <b>main.c</b>.
 *
 * - Build the project.
 *
 * \note The <b>Init</b> function will be created and its call at startup will be performed in scope of the
 * <b>init_cycfg_all()</b> function only if the "Initialize During Startup" checkbox is checked during configuration
 * process in the Device Configurator tool.
 * \image html init.png
 *
 * \section section_mcdi_usage_details Usage Details
 * \{
 * Assume the motor instance is named in the ModusToolbox&trade; Device Configurator Tool as <b>myMotor</b>.
 * \subsection subsection_mcdi_functions The MCDI Functions
 * \par
 * The simplest way to use <b>myMotor</b> is to use the \ref group_mcdi_gen_func "instance-based generated myMotor API":
 * \snippet fut_gen_snippet/main.c SNIPPET_GEN_FLOW
 * Or, as an alternative you can use the \ref group_mcdi_functions "MCDI data-driven API functions":
 * \snippet fut_dat_snippet/main.c SNIPPET_DAT_FLOW
 * The first is preferable.
 *
 * \subsection subsection_mcdi_control The MCDI Cascade Control
 * \par
 * The Solution Personality GUI and its code generation engine provide users a template to create a cascaded control
 * system with the inner and outer control loops.<br> The inner control loop name in MCDI is a Fast Control Loop, and
 * the outer control loop name is a Slow Control Loop.<br>
 * <br>The Fast Control Loop settings provide:
 * - automatic/manual allocation of hardware resources for the Sync timer functionality
 * - automatic/manual allocation of hardware resources for the Fast timer functionality
 * - Fast Control Loop frequency to PWM frequency ratio configuration
 * - Timer compare-value update time-point configuration
 * - ADC group conversion-start time-point configuration
 * - Fast Control Loop interrupt priority configuration
 * - Fast Control Loop callback-function name definition
 * - ADC conversion-result storage-array name definition
 * \par
 * The Slow Control Loop settings provide:
 * - automatic/manual allocation of hardware resources for the Slow timer functionality
 * - Slow Control Loop frequency to Fast Control Loop frequency ratio configuration
 * - Slow Control Loop interrupt-priority configuration
 * - Slow Control Loop callback-function name definition
 * \par
 * The Solution Personality code generation engine declares all user-predefined callbacks as external functions with
 * such a prototype:
 * \code {.c} extern uint16_t predefined_function_name(void) \endcode
 * Because of this, in the user application, the appropriate function definitions must be made at the global level.<br>
 * You can use as a template (in the main.c, for example), the functions from the code snippets listed below.
 * \anchor myMotor_slow_callback
 * \snippet 3shunt/main.c SNIPPET_SLOW_CALLBACK
 * \anchor myMotor_fast_callback
 * \snippet 3shunt/main.c SNIPPET_FAST_CALLBACK
 *
 * \subsection subsection_mcdi_inter_connectivity The MCDI resources interconnection and synchronization
 * \par
 * The MCDI Solution Personality occupies the following resources for each Motor Control instance:
 * - Three timers in PWM mode
 * - Three timers in Timer mode
 * - Two HPPASS SAR Sequencer groups, with three ADC channels in each
 * - Seven or eight GPIOs (depends on configuration)
 * - Two or three HW interrupts (depends on configuration)
 * \par
 * The Motor Control instance interconnection is shown in the picture below.
 * \image html MCDI_resources_interconnection.png
 * <br>
 * All the PWM, Sync and Fast timers are synchronized by the Personality engine and started synchronously. The Slow
 * Timer is not synchronized with the others and starts asynchronously.<br>
 * The instance-based \ref myMotor_start and the data-driven \ref mtb_mcdi_start functions are provided by MCDI
 * for this purpose.
 * \}
 * \}
 **/

#ifndef MTB_MCDI_H
#define MTB_MCDI_H

#include "cy_pdl.h"

#ifdef CY_IP_MXS40MCPASS

#if defined(__cplusplus)
extern "C" {
#endif


/******************************************************************************/
/** \cond SECTION_MDI_INTERNAL */
/** \addtogroup group_mtb_mcdi_internal *//** \{ */
/******************************************************************************/
#define CY_MCDI_MOTORS 2U
#define CY_MCDI_PWM_NUM 3U
#define CY_MCDI_TMR_NUM 3U
/** \} \endcond */

/** \addtogroup group_mcdi_macros
 * \{
 */
#define MTB_MCDI_PWM_U     (0U) /**< U-phase PWM index */
#define MTB_MCDI_PWM_V     (1U) /**< V-phase PWM index */
#define MTB_MCDI_PWM_W     (2U) /**< W-phase PWM index */

#define MTB_MCDI_TMR_SYNC     (0U) /**< Synchronization Timer index */
#define MTB_MCDI_TMR_FAST     (1U) /**< Fast Control Loop Timer index */
#define MTB_MCDI_TMR_SLOW     (2U) /**< Fast Control Loop Timer index */
/** \} group_mcdi_macros */

/***************************************
*       Enumerated Types
***************************************/
/** \addtogroup group_mcdi_topologies
 * \{
 */
/** The motor control topologies */
typedef enum
{
    MTB_MCDI_3SHUNT, /**< 3-shunt topology */
    MTB_MCDI_1SHUNT  /**< 1-shunt topology */
} mtb_en_mcdi_topo_t;
/** \} group_mcdi_topologies */

/** \addtogroup group_mcdi_status
 * \{
 */
/** Return status for functions of the driver for Motor Control Device Interface */
typedef enum
{
    CY_MCDI_SUCCESS           = CY_RSLT_SUCCESS, /**< Action was successful */
    CY_MCDI_BAD_PARAM         = CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR,
                                               CY_RSLT_GET_MODULE(CY_RSLT_MODULE_MIDDLEWARE_MCDI),
                                               0x0000UL) /**< The Input parameter is out of range or input pointer is
                                                          *   NULL and initialization could not be completed */
} cy_en_mcdi_status_t;
/** \} group_mcdi_status */

/** \addtogroup group_mcdi_data_structures
 * \{
 */
/** The single PWM sub-structure */
typedef struct
{
    uint32_t                          idx; /**< PWM TCPWM counter index */
    cy_stc_tcpwm_pwm_config_t const * cfg; /**< PWM configuration structure (common for U/V/W
                                            *   phases) */
} mtb_stc_mcdi_pwm_t;

/** The single Timer sub-structure */
typedef struct
{
    uint32_t                              idx; /**< Timer TCPWM counter index */
    cy_stc_tcpwm_counter_config_t const * cfg; /**< Timer configuration structure */
} mtb_stc_mcdi_tmr_t;

/** The single GPIO instance sub-structure */
typedef struct
{
    GPIO_PRT_Type * base; /**< Port Instance */
    uint32_t      pinNum; /**< Pin number */
} mtb_stc_mcdi_gpio_t;

/** The configuration structure */
typedef struct
{
    mtb_en_mcdi_topo_t                 topo; /**< Motor Control Topology */
    uint32_t                    fastIntrMsk; /**< Fast Control Loop interrupt mask */
    uint32_t                    slowIntrMsk; /**< Slow Control Loop interrupt mask */
    uint32_t                  syncStartTrig; /**< Synchronous start TrigMux line */
    TCPWM_Type *                  tcpwmBase; /**< TCPWM base */
    mtb_stc_mcdi_pwm_t pwm[CY_MCDI_PWM_NUM]; /**< Array of PWM structures */
    mtb_stc_mcdi_tmr_t tmr[CY_MCDI_TMR_NUM]; /**< Array of Timer structures */
    mtb_stc_mcdi_gpio_t const *       fault; /**< Fault pin instance */
} mtb_stc_mcdi_cfg_t;
/** \} group_mcdi_data_structures */

/** \addtogroup group_mcdi_functions
 *  \{
 */
/*******************************************************************************
* Function Name: mtb_mcdi_init
****************************************************************************//**
*
* Initializes all MCDI Timers and PWMs.
* The HPPASS is a common resource, it is initialized outside of the
* solution level (it can be common for multiple solutions).
*
* \param cfg The pointer to the configuration structure \ref mtb_stc_mcdi_cfg_t.
*
* \return The combined status if initialization of all the Timers and PWMs.
*
* \funcusage \snippet fut_dat_snippet/main.c SNIPPET_DAT_FLOW
*
*******************************************************************************/
cy_rslt_t mtb_mcdi_init(mtb_stc_mcdi_cfg_t const * cfg);


/*******************************************************************************
* Function Name: mtb_mcdi_enable
****************************************************************************//**
*
* Enables all MCDI Timers and PWMs.
* After this action, they are sensitive to input triggers.
*
* \return The execution status.
*
* \param cfg The pointer to the configuration structure \ref mtb_stc_mcdi_cfg_t.
*
* \funcusage \snippet fut_dat_snippet/main.c SNIPPET_DAT_FLOW
*
*******************************************************************************/
cy_rslt_t mtb_mcdi_enable(mtb_stc_mcdi_cfg_t const * cfg);


/*******************************************************************************
* Function Name: mtb_mcdi_disable
****************************************************************************//**
*
* Stops and Disables all MCDI Timers and PWMs.
*
* \return The execution status.
*
* \param cfg The pointer to the configuration structure \ref mtb_stc_mcdi_cfg_t.
*
* \funcusage \snippet fut_dat_snippet/main.c SNIPPET_DAT_FLOW
*
*******************************************************************************/
cy_rslt_t mtb_mcdi_disable(mtb_stc_mcdi_cfg_t const * cfg);


/*******************************************************************************
* Function Name: mtb_mcdi_start
****************************************************************************//**
*
* Starts all the PWMs and Sync and Fast Timers synchronously.
* Starts the Slow Timer asynchronously after that.
* The HPPASS is a common resource, it is configured and started before
* this function execution.
*
* \param cfg The pointer to the configuration structure \ref mtb_stc_mcdi_cfg_t.
*
* \return The Cy_TrigMux_SwTrigger status.
*
* \funcusage \snippet fut_dat_snippet/main.c SNIPPET_DAT_FLOW
*
*******************************************************************************/
cy_rslt_t mtb_mcdi_start(mtb_stc_mcdi_cfg_t const * cfg);

/** \} group_mcdi_functions */

#if defined(__cplusplus)
}
#endif

#endif /* CY_IP_MXS40MCPASS */

#endif /* MTB_MCDI_H */

/** \} group_mcdi_general */

/* [] END OF FILE */
