/***************************************************************************//**
* \file mtb_mcdi.h
* \version 2.0
*
* \brief
* Provides private declarations for the MCDI library.
*
********************************************************************************
* \copyright
* (c) (2025), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation. All rights reserved.
********************************************************************************
* This software, including source code, documentation and related materials
* ("Software") is owned by Cypress Semiconductor Corporation or one of its
* affiliates ("Cypress") and is protected by and subject to worldwide patent
* protection (United States and foreign), United States copyright laws and
* international treaty provisions. Therefore, you may use this Software only
* as provided in the license agreement accompanying the software package from
* which you obtained this Software ("EULA").
*
* If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
* non-transferable license to copy, modify, and compile the Software source
* code solely for use in connection with Cypress's integrated circuit products.
* Any reproduction, modification, translation, compilation, or representation
* of this Software except as specified above is prohibited without the express
* written permission of Cypress.
*
* Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. Cypress
* reserves the right to make changes to the Software without notice. Cypress
* does not assume any liability arising out of the application or use of the
* Software or any product or circuit described in the Software. Cypress does
* not authorize its products for use in any products where a malfunction or
* failure of the Cypress product may reasonably be expected to result in
* significant property damage, injury or death ("High Risk Product"). By
* including Cypress's product in a High Risk Product, the manufacturer of such
* system or application assumes all risk of such use and in doing so agrees to
* indemnify Cypress against all liability.
*******************************************************************************/

/**
 *<!-- The MCDI documentation structure -->
 * \defgroup group_mcdi_general Motor Control Driver Interface (MCDI)
 * \{
 *<!--  \defgroup group_mcdi_macros Macros -->
 *<!--  \{ -->
 *    \defgroup group_mcdi_status Status
 *<!--  \} -->
 *<!--  \defgroup group_mcdi_enums Enumerated Types -->
 *<!--  \{ -->
 *    \defgroup group_mcdi_topologies Topologies
 *<!--  \} -->
 *  \defgroup group_mcdi_data_structures Data Structures
 *<!--   \defgroup group_mcdi_functions Hidden Functions -->
 *  \defgroup group_mcdi_gen_func Functions
 * \}
 *<!-- End of the MCDI documentation structure -->
 *
 * \addtogroup group_mcdi_general
 * \{
 * The MCDI represents the device-agnostic top-level API source code, the control
 * service code, and the Solution Personality.
 * The Solution Personality:
 * - provides the integration with the Device Configurator
 * - provides a graphical configuration interface
 * - generates device-specific HW configuration code and the control code for the motor
 *   control applications
 * - generates templates for the fast and slow control loop ISRs
 * - supports Direct Memory Access (DMA) transfers for the ADC and Modulator data
 * - supports single-shunt and three-shunt load current measurement schemes
 * - supports up-to-two motor instances
 *
 * \image html MCDI_structure.png width=50%
 *
 * \section section_mcdi_quick_start Quick Start
 * \{
 * In order to use the MCDI as a standalone interface for alternative motor control libraries:
 *
 * - Create a New Application in ModusToolbox&trade; IDE
 * \par
 * \image html MakeNewApp.png width=9%
 *
 * - Use the 'Empty App' template.
 * \par
 * \image html UseTemplate.png
 *
 * - Add the 'motor-ctrl-lib' to the created application using the Library Manager
 * \par
 * \image html UseLibraryManager.png width=10%
 *
 * - Add this code into the project 'Makefile'
 * \par
 * \image html MakefileContent.png
 *
 * - Launch the Device Configurator
 * \par
 * \image html LaunchDeviceConfigurator.png width=12%
 *
 * - Add the Motor Control instance
 * \par
 * \image html myMotor.png
 *
 * - Configure all hardware-specific Motor Control solution parameters and save them (or press Ctrl+S to save).
 * After that, the appropriate code for the application will be generated by the Solution Personality.
 *
 * - Add both the \ref myMotor_slow_callback function definition and the \ref myMotor_fast_callback function
 * definition into the <b>main.c</b>.
 *
 * - Build the project.
 *
 * \section section_mcdi_usage_details Usage Details
 * \{
 * Assume the motor instance is named in the ModusToolbox&trade; Device Configurator Tool as <b>myMotor</b>.
 * \subsection subsection_mcdi_functions Application Programming Interface
 * \par
 * The simplest way to use <b>myMotor</b> is to use the \ref group_mcdi_gen_func "instance-based generated myMotor API":
 * \snippet evk_gen_snippet/main.c SNIPPET_GEN_FLOW
 * <br>
 * \note It is not recommended to use any MCDI FW items (definitions, enums, structures or functions)
 * from static sources or generated files which are not described in this document.
 *
 *<!-- Or, as an alternative you can use the \ref group_mcdi_functions "MCDI data-driven API functions": -->
 *<!-- \snippet evk_dat_snippet/main.c SNIPPET_DAT_FLOW -->
 *<!-- The first is preferable. -->
 *
 * \subsection subsection_mcdi_control Cascade Control
 * \par
 * The Solution Personality GUI and its code generation engine provide users a template to create a cascaded control
 * system with the inner and outer control loops.<br> The inner control loop name in MCDI is a Fast Control Loop, and
 * the outer control loop name is a Slow Control Loop.<br>
 * <br>The Fast Control Loop settings provide:
 * - Automatic/manual allocation of hardware resources for Sync timer functionality
 * - Automatic/manual allocation of hardware resources for Fast timer functionality
 * - Configuration of the Fast Control Loop frequency to PWM frequency ratio
 * - Configuration of the time point for updating the timer compare value
 * - Configuration of the time point for starting ADC group conversions
 * - Configuration of the Fast Control Loop interrupt priority
 * - Definition of the Fast Control Loop callback function identifier
 * \par
 * The Slow Control Loop settings provide:
 * - Automatic/manual allocation of hardware resources for the Slow timer functionality
 * - Slow Control Loop frequency to Fast Control Loop frequency ratio configuration
 * - Slow Control Loop interrupt-priority configuration
 * - Slow Control Loop callback-function name definition
 * \par
 * The Solution Personality code generation engine declares all user-predefined callbacks as external functions with
 * such a prototype:
 * \code {.c} extern uint16_t predefined_function_name(void) \endcode
 * Because of this, in the user application, the appropriate function definitions must be made at the global level.<br>
 * You can use as a template (in the main.c, for example), the functions from the code snippets listed below.
 * \anchor myMotor_slow_callback
 * \snippet 3shunt/main.c SNIPPET_SLOW_CALLBACK
 * \anchor myMotor_fast_callback
 * \snippet 3shunt/main.c SNIPPET_FAST_CALLBACK
 *
 * \subsection subsection_mcdi_inter_connectivity Resources interconnection and synchronization
 * \par
 * The MCDI Solution Personality occupies the following resources for each Motor Control instance:
 * - Three timers in PWM mode
 * - Three timers in Timer mode
 * - Two ADC Sequencer groups, the number of the ADC channels in each is configuration-dependent
 * - Seven or eight GPIOs (depends on configuration)
 * - Two or three HW interrupts (depends on configuration)
 * \par
 * The Motor Control instance resource interconnection depends on the selected measurement scheme.
 * The difference is highlighted in the picture below.
 * \image html MCDI_resources_interconnection.png width=60%
 * <br>
 * All the PWM, Sync, Fast timers start synchronously, and the Slow timer starts asynchronously.<br>
 * The instance-based \ref myMotor_start function is provided by MCDI for this purpose.<br>
 * The Fast timer generates one output pulse trigger on the compare event in the Three-shunt topology, and two output
 * pulse triggers in the Single-shunt topology. The trigger points are configurable;<br>
 * the only difference is that because of additional swap trigger used in the Single-shunt topology, the trigger
 * points can be changed by software on the fly.
 *
 * \subsection subsection_mcdi_dma Direct Memory Access
 * The MCDI supports DMA transfers for the ADC and Modulator data, which enables MCU offloading and reduces the Fast ISR
 * duration. These two features are independent and can be used simultaneously or separately.
 * \anchor par_mcdi_dma_adc \par ADC DMA
 * The ADC DMA functionality is enabled by checking the "Use DMA" checkbox in the "ADC" subgroup of the MCDI
 * configurations.
 * \image html ADC_DMA_enable.png
 * The ADC DMA transfers all conversion results of the ADC channels triggered by the Fast timer from Result registers to
 * their respective memory locations. The ADC DMA channel is triggered automatically by the Group Done event.
 *
 * \anchor par_mcdi_dma_mod \par Modulator DMA
 * The Modulator DMA functionality is enabled by checking the "Use DMA" checkbox in the "PWM" subgroup of the MCDI
 * configurations.
 * \image html Modulator_DMA_enable.png
 * The Modulator DMA transfers the modulator compare values from memory locations to their respective hardware Compare
 * Buffer registers. The DMA transfer does not start automatically, to start it, the \ref myMotor_mod_update function
 * shall be called.
 * \}
 * \}
 **/

#ifndef MTB_MCDI_H
#define MTB_MCDI_H

#include "cy_pdl.h"

#ifdef CY_IP_MXS40MCPASS

#if defined(__cplusplus)
extern "C" {
#endif


/***************************************
*       Macros
***************************************/
/** \cond Internal definitions */
#define MTB_MCDI_PWM_NUM 4U /**< Number of timers in PWM mode */
#define MTB_MCDI_TMR_NUM 2U /**< Number of timers in Counter mode */

#define MTB_MCDI_PWM_U     (0U) /**< U-phase PWM index */
#define MTB_MCDI_PWM_V     (1U) /**< V-phase PWM index */
#define MTB_MCDI_PWM_W     (2U) /**< W-phase PWM index */
#define MTB_MCDI_TMR_FAST  (3U) /**< Fast Control Loop Timer index */

#define MTB_MCDI_TMR_SYNC     (0U) /**< Synchronization Timer index */
#define MTB_MCDI_TMR_SLOW     (1U) /**< Slow Control Loop Timer index */
/** \endcond */

/** \addtogroup group_mcdi_status
 * Statuses for the MCDI API functions
 * \{
 */
/** The action was successful */
#define MTB_MCDI_SUCCESS   CY_RSLT_SUCCESS
/** The Input parameter is out of range or input pointer is NULL */
#define MTB_MCDI_BAD_PARAM CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_MIDDLEWARE_MCDI, 1UL)
/** \} group_mcdi_status */

/***************************************
*       Enumerated Types
***************************************/
/** \addtogroup group_mcdi_topologies
 * Topologies of current measurement
 * \{
 */
/** The current measurement topologies */
typedef enum
{
    MTB_MCDI_3SHUNT, /**< Three-shunt topology */
    MTB_MCDI_1SHUNT  /**< Single-shunt topology */
} mtb_en_mcdi_topo_t;
/** \} group_mcdi_topologies */

/** \addtogroup group_mcdi_data_structures
 * Interface data structures
 * \{
 */

/** \cond Internal */
/** The single PWM sub-structure */
typedef struct
{
    uint32_t                          idx; /**< PWM TCPWM counter index */
    cy_stc_tcpwm_pwm_config_t const * cfg; /**< PWM configuration structure (common for U/V/W
                                            *   phases) */
} mtb_stc_mcdi_pwm_t;

/** The single Timer sub-structure */
typedef struct
{
    uint32_t                              idx; /**< Timer TCPWM counter index */
    cy_stc_tcpwm_counter_config_t const * cfg; /**< Timer configuration structure */
} mtb_stc_mcdi_tmr_t;

/** The single MODULATOR sub-structure */
typedef struct
{
    uint16_t cmp0; /**< Timer Counter compare0 value */
    uint16_t cmp1; /**< Timer Counter compare1 value */
} mtb_stc_mcdi_mod_t;

/** The single GPIO instance sub-structure */
typedef struct
{
    GPIO_PRT_Type * base; /**< Port Instance */
    uint32_t      pinNum; /**< Pin number */
} mtb_stc_mcdi_gpio_t;
/** \endcond */

/** The configuration structure */
typedef struct
{
    mtb_en_mcdi_topo_t                  topo; /**< Motor Control Topology */
    uint32_t                     fastDivider; /**< PWM to Fast Loop Frequency Ratio */
    uint32_t                     slowDivider; /**< Fast to Slow Loop Frequency Ratio */
    float32_t                pwmClkFrequency; /**< PWM Clocking Frequency */
    float32_t                 pwmSwFrequency; /**< PWM Switching Frequency */
/** \cond Internal */
    uint32_t                     fastIntrMsk; /**< Fast Control Loop interrupt mask */
    uint32_t                     slowIntrMsk; /**< Slow Control Loop interrupt mask */
    uint32_t                   syncStartTrig; /**< Synchronous start TrigMux line */
    TCPWM_Type *                   tcpwmBase; /**< TCPWM base */
    mtb_stc_mcdi_gpio_t const *        fault; /**< Fault pin instance */
    mtb_stc_mcdi_pwm_t pwm[MTB_MCDI_PWM_NUM]; /**< Array of PWM structures */
    mtb_stc_mcdi_tmr_t tmr[MTB_MCDI_TMR_NUM]; /**< Array of Timer structures */
/** \endcond */
} mtb_stc_mcdi_cfg_t;
/** \} group_mcdi_data_structures */

/** \cond Internal functions */
/** \addtogroup group_mcdi_functions
 *  \{
 */

/*******************************************************************************
* Function Name: mtb_mcdi_init
****************************************************************************//**
* Initializes all MCDI Timers and PWMs.
* The HPPASS is a common resource, it is initialized outside of the
* solution level (it can be common for multiple solutions).
*
* \param cfg The pointer to the configuration structure \ref mtb_stc_mcdi_cfg_t.
*
* \return The combined status if initialization of all the Timers and PWMs.
*******************************************************************************/
cy_rslt_t mtb_mcdi_init(mtb_stc_mcdi_cfg_t const * cfg);


/*******************************************************************************
* Function Name: mtb_mcdi_enable
****************************************************************************//**
* Enables all MCDI Timers and PWMs. After this action, they are sensitive to input triggers.
*
* \param cfg The pointer to the configuration structure \ref mtb_stc_mcdi_cfg_t.
*
* \return The execution status.
*******************************************************************************/
cy_rslt_t mtb_mcdi_enable(mtb_stc_mcdi_cfg_t const * cfg);


/*******************************************************************************
* Function Name: mtb_mcdi_disable
****************************************************************************//**
* Disables (stops) all modulator required timers, provides backward interface compatibility.
*
* \param cfg The pointer to the configuration structure \ref mtb_stc_mcdi_cfg_t.
*
* \return The execution status.
*******************************************************************************/
cy_rslt_t mtb_mcdi_disable(mtb_stc_mcdi_cfg_t const * cfg);


/*******************************************************************************
* Function Name: mtb_mcdi_start
****************************************************************************//**
* Starts all modulator required timers, provides backward interface compatibility.
*
* \param cfg The pointer to the configuration structure \ref mtb_stc_mcdi_cfg_t.
*
* \return The Cy_TrigMux_SwTrigger status.
*******************************************************************************/
cy_rslt_t mtb_mcdi_start(mtb_stc_mcdi_cfg_t const * cfg);

/** \} group_mcdi_functions */
/** \endcond Internal functions */

#if defined(__cplusplus)
}
#endif

#endif /* CY_IP_MXS40MCPASS */

#endif /* MTB_MCDI_H */

/** \} group_mcdi_general */

/* [] END OF FILE */
